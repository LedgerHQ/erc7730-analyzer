{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ERC-7730 Critical Issues Criteria",
  "description": "Detailed criteria for what constitutes a CRITICAL issue in ERC-7730 clear signing security audits",
  "version": "2.0.0",

  "definition": "CRITICAL = USER LOSES MONEY OR GETS WRONG TOKENS/AMOUNTS IN FINAL OUTCOME. Only flag if a normal user would be shocked by what actually happens.",

  "rule": "You MUST be EXTREMELY conservative. Only flag if a normal user would be shocked by what actually happens.",

  "critical_requirements": [
    {
      "requirement": "Array indexing validation",
      "description": "When ERC-7730 uses array indexing, verify the index points to actual data relevant to the user (not sentinel values)"
    },
    {
      "requirement": "Can it be fixed?",
      "description": "ONLY flag as CRITICAL if the issue EXISTS in function inputs AND can be displayed with ERC-7730 spec AND can be shown in human-readable format"
    },
    {
      "requirement": "Human readability",
      "description": "Parameters that can ONLY be shown as incomprehensible raw data (packed bits, liquidity numbers, technical params) are NOT critical to hide"
    },
    {
      "requirement": "Slicing uint256 values",
      "description": "When field paths use slice syntax (e.g., `[-20:]`, `[0:16]`):",
      "rules": [
        "CRITICAL if slicing **financial amounts** (tokenAmount format, or names like: min*, max*, balance, price, amount, value, fee, debt) → values can exceed slice size, showing incorrect amounts",
        "NOT CRITICAL if slicing **packed address types** where source code shows custom types (`type X is uint256`) with flags/metadata in high bits → intentional extraction",
        "**Be consistent**: similar patterns across different functions must receive the same assessment unless there's material contextual difference"
      ]
    }
  ],

  "do_NOT_flag_as_critical": {
    "title": "CRITICAL: What NOT to flag as missing fields",
    "rule": "If displaying a parameter would NOT help users understand or verify the transaction, do NOT flag it as critical",
    "examples": [
      {
        "parameter": "makerTraits (bitpacked uint256)",
        "what_it_controls": "Cancellation mode, nonce, epoch, various flags via bitwise operations",
        "why_NOT_critical": "Displaying as raw shows '0x00000000000000000000000000000000000000000000000000000000000001a4' - users CANNOT understand what this means. This is INCOMPREHENSIBLE to users.",
        "action": "Add to spec limitations, NOT critical issues"
      },
      {
        "parameter": "flags (bitmask)",
        "what_it_controls": "Multiple behavior flags via bitwise AND operations",
        "why_NOT_critical": "Raw hex like '0x06' is meaningless - users cannot determine which flags are set",
        "action": "Add to spec limitations, NOT critical issues"
      },
      {
        "parameter": "Packed data (multiple values in one uint256)",
        "why_NOT_critical": "Cannot be decomposed with ERC-7730 spec - raw display is incomprehensible",
        "action": "Add to spec limitations, NOT critical issues"
      },
      {
        "parameter": "Technical parameters (liquidity, sqrtPriceX96, tick, feeGrowthGlobal0X128)",
        "why_NOT_critical": "Users cannot verify correctness without deep protocol knowledge - raw numbers are meaningless",
        "action": "Add to spec limitations, NOT critical issues"
      },
      {
        "parameter": "Concatenated bytes with separate length array (data + dataLengths)",
        "what_it_controls": "Multiple calldata blobs concatenated together, sliced using separate lengths array",
        "source_code_pattern": "data.slice(position, dataLengths[i]) - splits concatenated blob dynamically",
        "why_NOT_critical": "ERC-7730 cannot dynamically slice a concatenated bytes blob using another array. The 'format: calldata' expects discrete per-transaction data, not a blob requiring parsing. Displaying raw concatenated bytes is INCOMPREHENSIBLE.",
        "action": "Add to spec limitations, NOT critical issues. Do NOT propose format: calldata on the concatenated blob.",
        "example": "executeHotfix(values[], destinations[], data, dataLengths[]) where data contains all calldatas joined and must be split per dataLengths[i]"
      },
      {
        "parameter": "Role/context information not in function parameters",
        "what_it_controls": "Function operates on a specific role (e.g., Validator, Attestation) or has implicit behavior (e.g., sets as default) but this information is in the function name/selector, not in parameters",
        "source_code_pattern": "Function name like authorizeValidatorSigner, authorizeAttestationSigner, setIndexedSigner with hardcoded role constants",
        "why_NOT_critical": "ERC-7730 cannot inject contextual metadata that isn't in the function inputs. Adding literal value fields ({value: 'Validator', label: 'Role'}) creates confusing separate hardware wallet screens showing standalone text. The intent field can partially address this (e.g., 'Authorize Validator') within the 20-character limit, but cannot fully convey complex multi-part information like 'authorizes validator AND sets as default'.",
        "action": "Add to spec limitations, NOT critical issues. Do NOT recommend adding literal value fields for role/context - they create poor UX on hardware wallets.",
        "example": "authorizeValidatorSigner(address signer, ...) where 'Validator' role is implicit in function name, or setIndexedSigner() where 'sets as default' is implicit behavior"
      }
    ],
    "key_principle": "Only flag as CRITICAL if showing the parameter would help users UNDERSTAND and VERIFY what they're signing. If the value would be INCOMPREHENSIBLE raw hex/numbers, it's NOT critical to hide it."
  },

  "explanation_format": {
    "title": "How to write critical issue explanations",
    "description": "Critical issue explanations must be CONCISE, DIRECT, and focus on USER IMPACT",
    "requirements": {
      "focus_on": "What the user CANNOT see and why it matters for their money/tokens",
      "be_concise": "Get straight to the point - what's missing and what's the risk",
      "avoid": [
        "Long explanations of contract internals",
        "Detailed technical descriptions of how the contract works",
        "Step-by-step analysis of the source code",
        "Multiple sentences explaining the background"
      ],
      "structure": "Missing display of [WHAT], while the contract [WHAT HAPPENS], and [PARAMETER] is excluded/wrong, so the user cannot see [CRITICAL INFO] which is a direct [RISK TYPE] and therefore critical."
    },
    "bad_example": "Target address embedded in 'args' can change the external target to which the order is filled but 'args' is excluded from the descriptor and no field shows this target address or its presence. When takerTraits.argsHasTarget() is set, the contract reads the first 20 bytes of args as the target address (target = address(bytes20(args))). The current ERC-7730 descriptor excludes 'args' entirely and does not display the extracted target address nor indicate that a target override is present. This hides a security-critical fact: the order fill may be sent to a third-party contract or recipient different from the default (msg.sender). Users will not see or be warned that the order's execution target is changed by the hidden 'args' bytes and could be sending funds or invoking logic on an unexpected contract.",
    "good_example": "Missing display of the actual recipient (the resolved 'target' parsed from args) while the contract sends the maker's token to that target, and args is excluded from display, so the user cannot see where the maker-side tokens will be delivered which is a direct recipient risk and therefore critical.",
    "key_difference": "The good example is ONE concise sentence that states: what's missing + what the contract does + why user can't see it + what the risk is. The bad example has 4-5 sentences with excessive technical details about how the contract works internally.",
    "template": "Missing display of [WHAT USER NEEDS TO SEE] while the contract [WHAT IT DOES WITH USER'S MONEY/TOKENS], and [DESCRIPTOR PROBLEM], so the user cannot see [CRITICAL INFORMATION] which is a direct [recipient/amount/token] risk and therefore critical."
  },

  "critical_criteria": [
    {
      "id": 1,
      "title": "Final amount IN is WRONG",
      "description": "User sends 100 USDC but ERC-7730 shows 50 USDC",
      "severity": "critical"
    },
    {
      "id": 2,
      "title": "Final amount OUT is WRONG",
      "description": "User receives 1 ETH but ERC-7730 shows 2 ETH",
      "severity": "critical"
    },
    {
      "id": 3,
      "title": "Token addresses INVERTED",
      "description": "ERC-7730 shows 'USDC→DAI' but logs show 'DAI→USDC'",
      "severity": "critical"
    },
    {
      "id": 4,
      "title": "Completely WRONG token",
      "description": "ERC-7730 shows user sends/receives USDC but they actually send/receive DAI",
      "exception": {
        "description": "If tokenPath points to user-supplied parameter (e.g., sendingAssetId) but contract mechanism differs (e.g., sends native ETH from address(this).balance), this is a DISPLAY ISSUE, NOT CRITICAL",
        "reasons": [
          "The user chose the token ID in their input parameters",
          "The amount is still correct",
          "The display is showing what the user specified in their input, not a fundamentally different token",
          "Flag this in the detailed 'Display Issues' section instead"
        ],
        "critical_if": "The displayed token is completely unrelated to any user input (e.g., hardcoded wrong address or pointing to wrong parameter)"
      },
      "severity": "critical"
    },
    {
      "id": 5,
      "title": "Missing RECIPIENT parameter",
      "cases": [
        {
          "case": "A",
          "condition": "If recipient IS an INPUT parameter that receives funds and is NOT shown",
          "severity": "critical"
        },
        {
          "case": "B",
          "condition": "If recipient is NOT in ABI inputs (because it's always msg.sender) BUT is important to show",
          "checks": [
            "Check if function always sends tokens/ETH to the sender (e.g., withdraw(), claimRewards(), unwrap())",
            "If YES and NO recipient field exists → Recommend using {\"path\": \"@.from\", \"label\": \"Beneficiary\", \"format\": \"addressName\"}",
            "This shows the user they're receiving funds to their own address"
          ],
          "severity": "recommendation"
        },
        {
          "case": "C",
          "condition": "If recipient IS an INPUT parameter BUT code shows conditional fallback to msg.sender",
          "pattern": "(param == address(0)) ? msg.sender : param",
          "checks": [
            "Check source code for pattern: (param == address(0)) or similar zero-check",
            "If recipient field exists WITHOUT senderAddress param → Add WARNING in detailed report",
            "Should recommend adding \"senderAddress\": [\"0x0000000000000000000000000000000000000000\"]",
            "This allows wallet to display @.from when user passes zero address"
          ],
          "note": "Special transaction fields: @.from = sender address, @.value = native currency value sent with tx",
          "severity": "warning"
        }
      ]
    },
    {
      "id": 6,
      "title": "Broken $ref references",
      "description": "Format references non-existent definitions/constants (display will fail)",
      "severity": "critical"
    },
    {
      "id": 7,
      "title": "Input parameter path mismatch",
      "description": "ERC-7730 references a parameter path that doesn't exist in the ABI OR uses wrong path/name",
      "valid_path_syntax": {
        "note": "Both '#.paramName' and 'paramName' are VALID - relative paths are equivalent to '#.' root",
        "valid_examples": [
          "#._minimumRepriceTime - VALID (explicit root)",
          "_minimumRepriceTime - VALID (relative, equivalent to #._minimumRepriceTime)",
          "params.amount - VALID (relative)",
          "#.params.amount - VALID (explicit root)"
        ],
        "root_nodes": {
          "#": "ABI parameters (structured data schema)",
          "$": "ERC-7730 file references (definitions, constants, enums)",
          "@": "Transaction container (value, to, from)"
        }
      },
      "examples": [
        "format shows '_receiver' but ABI has 'receiver'",
        "shows '_tokens[0]' but should be '_swapData[0].token'"
      ],
      "not_critical": [
        "DO NOT flag '#._paramName' as invalid - this is correct syntax for ABI parameters",
        "DO NOT flag relative paths like '_paramName' as invalid - they are equivalent to '#._paramName'"
      ],
      "severity": "critical"
    },
    {
      "id": "7b",
      "title": "Format validation failures",
      "validations": [
        {
          "type": "tokenAmount without token specification",
          "condition": "Field has \"format\": \"tokenAmount\" but missing BOTH \"tokenPath\" AND \"token\" in params",
          "token_specification_options": [
            "Dynamic (from parameter): \"tokenPath\": \"paramName\" - token address comes from function input",
            "Fixed (hardcoded): \"token\": \"0x...\" - for migration contracts or functions operating on single specific token"
          ],
          "critical_if": "NEITHER is present UNLESS one of these exceptions applies",
          "exceptions": [
            "Function ONLY supports native ETH (check source code: no ERC20 support, hardcoded ETH) AND has nativeCurrencyAddress",
            "Token address is NOT in function inputs (computed from pool/DEX, encoded in bytes, determined on-chain) AND has nativeCurrencyAddress - this is VALID and NOT CRITICAL"
          ],
          "exception_2_detailed_explanation": {
            "title": "tokenAmount with ONLY nativeCurrencyAddress (no tokenPath or token) is VALID when output token cannot be determined and can be native sentinel ETH address",
            "when_this_is_NOT_critical": [
              "Output token is determined by pool/DEX address (not in function inputs)",
              "Output token is computed on-chain from routing logic",
              "The descriptor has nativeCurrencyAddress to handle native ETH case",
              "For ERC20 outputs, the wallet will show raw amount without symbol (acceptable limitation)"
            ],
            "example_valid_case": {
              "function": "ethUnoswap2(uint256 minReturn, bytes32[] dex)",
              "definition": "minReceiveAmount: {\"format\": \"tokenAmount\", \"params\": {\"nativeCurrencyAddress\": [\"$.metadata.constants.addressAsEth\", \"$.metadata.constants.addressAsNull\"]}}",
              "why_valid": "Output token is determined by DEX/pool routing (not in function inputs). When output is native ETH (matching nativeCurrencyAddress), it displays properly as ETH. When output is an ERC20, wallet shows raw amount without symbol - this is an acceptable spec limitation.",
              "action": "NOT CRITICAL - this is correct usage. Do NOT flag as issue. If you want to mention it, add to spec limitations: 'Output token cannot be determined from inputs (computed by DEX routing), so ERC20 amounts display without token symbol.'"
            },
            "when_this_IS_critical": "Only flag as critical if the token address IS in function inputs but descriptor doesn't reference it with tokenPath"
          },
          "spec_limitation": "If exception 2 applies (token determined by pool): This is a SPEC LIMITATION - Add to 'Parameters that cannot be clear signed' section, NOT to critical issues. Example: 'Output token cannot be clear signed because it is determined by the pool/DEX and not an explicit function input'",
          "severity": "critical_with_exceptions"
        },
        {
          "type": "nftName without collectionPath",
          "condition": "Field has \"format\": \"nftName\" but missing \"collectionPath\" in params",
          "severity": "critical"
        },
        {
          "type": "enum without reference",
          "condition": "Field has \"format\": \"enum\" but missing $ref to metadata.constants OR metadata.enums",
          "severity": "critical"
        },
        {
          "type": "calldata without callee",
          "condition": "Field has \"format\": \"calldata\" but missing BOTH \"calleePath\" AND \"callee\" in params",
          "explanation": "Embedded calldata requires knowing which contract is being called to find the correct ERC-7730 descriptor for the nested call",
          "severity": "critical"
        },
        {
          "type": "calldata with both callee and calleePath",
          "condition": "Field has \"format\": \"calldata\" with BOTH \"calleePath\" AND \"callee\" in params (XOR violation)",
          "explanation": "Must specify EITHER calleePath (dynamic) OR callee (fixed), not both",
          "severity": "critical"
        },
        {
          "type": "calldata XOR violations",
          "description": "Other XOR constraint violations in calldata format",
          "violations": [
            "Both selector AND selectorPath present (use one or neither)",
            "Both chainId AND chainIdPath present (use one or neither)",
            "Both amount AND amountPath present (use one or neither)",
            "Both spender AND spenderPath present (use one or neither)"
          ],
          "severity": "critical"
        },
        {
          "type": "Wrong format type",
          "description": "Using wrong format (e.g., 'amount' for ERC20 token, or 'tokenAmount' without tokenPath)",
          "exceptions": [
            {
              "type": "Type casting uint256/bytes32 ↔ address",
              "description": "Using \"addressName\" format on uint256, bytes32, or bytes20 ABI type is VALID (casting is supported by taking 20 bytes). Similarly, using \"raw\" or numeric formats on address type is valid. These are NOT critical type mismatches."
            },
            {
              "type": "Token amount as raw when token cannot be determined",
              "description": "If a field displays a token amount (e.g., amountOut, minReceive) but uses \"format\": \"raw\" instead of \"tokenAmount\", this is ACCEPTABLE if the token address cannot be determined from function inputs (e.g., output token is computed from pool addresses/routes). This is NOT critical - it's a known concession.",
              "action": "Only mention in recommendations: 'User will see raw amount without token symbol/decimals because output token cannot be determined from inputs.'"
            }
          ],
          "note": "Check BOTH the field params AND any $ref definition params for these requirements",
          "severity": "critical_with_exceptions"
        },
        {
          "type": "Date/timestamp format with unreasonably large values",
          "description": "Using \"format\": \"date\" with \"encoding\": \"timestamp\" on values that are NOT valid Unix timestamps",
          "validation": "Unix timestamps should be reasonable values (typically 10-13 digits for dates between 1970-2286). Values larger than 2^40 (~1.1 trillion, year 36,812) are NOT valid timestamps.",
          "critical_patterns": [
            {
              "pattern": "Huge uint256 value formatted as timestamp",
              "example": "goodUntil: 169651817337550577389281124630292667735310025728713516845115 formatted as date",
              "why_critical": "This is clearly NOT a Unix timestamp - likely bitpacked data or different encoding. User will see meaningless date (overflow or year 10^45) instead of actual expiration",
              "how_to_detect": "If using format: date with encoding: timestamp, check transaction samples. If decoded value is > 2^40, it's NOT a valid timestamp"
            }
          ],
          "action": "Flag as CRITICAL: 'Field uses date format with timestamp encoding, but the actual value is unreasonably large (not a valid Unix timestamp). User will see meaningless date instead of actual expiration time.'",
          "note": "This requires checking actual transaction data - cannot be detected from descriptor alone",
          "severity": "critical"
        }
      ]
    },
    {
      "id": 8,
      "title": "Native ETH handling in payable functions",
      "description": "For what the user sends and all functions even non payable for what he receives (this is critical and nuanced)",
      "pre_check": {
        "title": "CRITICAL PRE-CHECK - Function payability",
        "description": "Check if the MAIN function (the one being clear signed) is marked payable in the ABI",
        "rules": [
          "If the main function is NOT payable → msg.value is ALWAYS 0, even if it calls internal payable functions",
          "Example: uniswapV3SwapToWithPermit() is NOT payable but calls uniswapV3SwapTo() which is payable",
          "In this case, the internal function's payable logic will NEVER execute because msg.value == 0",
          "Do NOT flag missing @.value if the main function is not payable"
        ]
      },
      "non_payable_with_eth_option": {
        "condition": "If a function is NOT payable but the descriptor includes nativeCurrencyAddress (showing ETH as possible input)",
        "severity": "NOT CRITICAL - UX improvement recommendation only",
        "reasons": [
          "The transaction will revert if user tries to send ETH to a non-payable function (no funds lost)",
          "The UI/frontend likely prevents this anyway"
        ],
        "action": "Add to RECOMMENDATIONS: 'Function is not payable but descriptor shows ETH as possible input. Consider removing nativeCurrencyAddress for better UX to prevent users from selecting ETH which would cause transaction to revert.'",
        "note": "Do NOT add to critical issues"
      },
      "scope": "These rules apply to BOTH what the user SENDS and what the user RECEIVES",
      "how_to_check": "For EACH field that displays a token amount, check if that field OR its $ref definition has native ETH support",
      "format_types": {
        "tokenAmount": "Can display ANY ERC20 token + native ETH (if nativeCurrencyAddress specified)",
        "amount_with_at_value": "Shows msg.value (native ETH sent with tx)"
      },
      "cases": [
        {
          "case": 1,
          "title": "Field with format tokenAmount and tokenPath to potential native ETH sentinel",
          "steps": [
            "Step 1: Look at the field showing the amount",
            "Step 2a: If field has $ref, look up that definition in display.definitions",
            "Step 2b: Check if the DEFINITION has nativeCurrencyAddress in its params",
            "Step 3: If no $ref, check if the FIELD itself has nativeCurrencyAddress in its params"
          ],
          "critical_if": "If NEITHER the field NOR its referenced definition has nativeCurrencyAddress, native ETH won't display correctly",
          "examples": {
            "correct_via_ref": {
              "field": "{\"path\": \"_amount\", \"$ref\": \"$.display.definitions.tokenAmount\", \"params\": {\"tokenPath\": \"_token\"}}",
              "definition": "{\"tokenAmount\": {\"format\": \"tokenAmount\", \"params\": {\"nativeCurrencyAddress\": [\"$.metadata.constants.addressAsEth\"]}}}"
            },
            "correct_direct": "{\"path\": \"_amount\", \"format\": \"tokenAmount\", \"params\": {\"tokenPath\": \"_token\", \"nativeCurrencyAddress\": [\"$.metadata.constants.addressAsEth\"]}}",
            "wrong": "{\"path\": \"_amount\", \"format\": \"tokenAmount\", \"params\": {\"tokenPath\": \"_token\"}} (no nativeCurrencyAddress anywhere)"
          }
        },
        {
          "case": 2,
          "title": "Field with path @.value",
          "description": "This directly shows msg.value (ETH sent with transaction)",
          "format": "Typically 'amount', not 'tokenAmount'",
          "example": "{\"path\": \"@.value\", \"label\": \"Amount\", \"format\": \"amount\"}"
        },
        {
          "case": 3,
          "title": "Payable function that accepts native ETH (especially WETH deposit or similar)",
          "critical_check": "Does the ERC-7730 display the ETH amount being sent?",
          "critical_conditions": [
            "If fields array is EMPTY or has NO amount fields → CRITICAL (nothing is shown to user)",
            "If function ONLY accepts native ETH (no token parameter) and no @.value field exists → CRITICAL",
            "If function accepts both tokens and ETH: Only NOT critical if another amount field displays the same value (e.g., deposit(uint256 amount) where amount must equal msg.value)"
          ],
          "NOT_CRITICAL_when_tokenAmount_has_nativeCurrencyAddress": {
            "title": "CRITICAL: Do NOT flag missing @.value when tokenAmount field already handles native ETH",
            "rule": "If a tokenAmount field (either directly or via $ref) has nativeCurrencyAddress, and the tokenPath points to a token parameter that can be an ETH sentinel address, then that field ALREADY displays native ETH amounts. Adding @.value would create DUPLICATE display.",
            "detection_steps": [
              "Step 1: Check if descriptor has a tokenAmount field with tokenPath pointing to a token address parameter",
              "Step 2: Check if that field has $ref - if yes, look up the definition",
              "Step 3: Check if the definition (or field itself) has nativeCurrencyAddress parameter",
              "Step 4: If YES → That field ALREADY displays native ETH when token is sentinel. DO NOT flag missing @.value"
            ],
            "concrete_example": {
              "descriptor": {
                "field": "{\"path\": \"baseRequest.fromTokenAmount\", \"$ref\": \"$.display.definitions.sendAmount\", \"params\": {\"tokenPath\": \"baseRequest.fromToken.[-20:]\"}}",
                "definition": "{\"sendAmount\": {\"format\": \"tokenAmount\", \"params\": {\"nativeCurrencyAddress\": [\"0xEeee...\", \"0x0000...\"]}}}"
              },
              "why_NOT_critical": "The sendAmount definition has nativeCurrencyAddress. When baseRequest.fromToken is 0xEeee...eE (ETH sentinel), the fromTokenAmount field will display the amount as native ETH. This ALREADY shows msg.value equivalent. Adding @.value would duplicate the display.",
              "action": "DO NOT flag as missing @.value. DO NOT recommend adding @.value field."
            },
            "when_it_IS_critical": "Only flag missing @.value if NONE of the tokenAmount fields have nativeCurrencyAddress (neither directly nor via $ref definition)"
          },
          "fix_example": "{\"path\": \"@.value\", \"label\": \"Amount\", \"format\": \"amount\"}"
        },
        {
          "case": 4,
          "title": "WRAPPER/FORWARDING PATTERN (INFORMATIONAL, not CRITICAL)",
          "pattern_detection": "If a payable function meets ALL these conditions",
          "conditions": [
            "Function body does NOT manipulate msg.value in its own logic (no validation, no splitting, no storing)",
            "Function forwards the ENTIRE value via: delegatecall(...), .call{value: msg.value}(...), or .call{value: address(this).balance}(...)",
            "Function does NOT display @.value in ERC-7730"
          ],
          "why_not_critical": [
            "The value is forwarded entirely to a nested call",
            "The nested call (typically decoded from a bytes calldata parameter like action, data, or calls) will have its own ERC-7730 descriptor",
            "That nested descriptor SHOULD display @.value",
            "Users see multiple clear signing screens: one for the wrapper, one for the nested call",
            "The value is shown on the nested call's screen, not the wrapper's screen",
            "Wallet UI also shows total transaction value regardless"
          ],
          "wrapper_patterns": [
            "delegatecall(...) - automatically forwards msg.value",
            ".call{value: msg.value}(...) - explicitly forwards full msg.value",
            ".call{value: address(this).balance}(...) - forwards all received ETH"
          ],
          "counter_example": {
            "description": "If function validates or manipulates msg.value",
            "code": "require(msg.value == desc.amount); // ❌ Uses msg.value in logic",
            "result": "This IS critical because function validates msg.value"
          },
          "action": "Mark as INFORMATIONAL (not CRITICAL) with note: 'This appears to be a wrapper function that forwards execution and value entirely. Verify that nested call descriptors display @.value.'",
          "severity": "informational"
        }
      ],
      "additional_checks": [
        "Check source code and receipt_logs (if available) to determine which case applies",
        "Sometimes even if sentinels exist, the code does not allow native transfer even if the function is payable",
        "KEY: When checking for nativeCurrencyAddress, follow $ref references to definitions - it can be in either place",
        "Only flag as critical if native ETH is actually being transferred AND display cannot show it"
      ]
    },
    {
      "id": 9,
      "title": "Amounts are displayed twice",
      "severity": "critical"
    },
    {
      "id": 10,
      "title": "Spelling/grammar errors in labels or intent",
      "severity": "critical"
    },
    {
      "id": "10b",
      "title": "Misleading or incorrect labels and intents",
      "description": "Labels or intents that mislead users about what a field represents or what action is being performed",
      "severity": "critical",
      "check_intent_accuracy": {
        "description": "The intent field must accurately describe the ACTUAL operation the function performs",
        "critical_examples": [
          {
            "wrong": "Intent: 'Cancel all limit orders' for increaseEpoch() function",
            "why_critical": "Says 'all orders' but function only increments user's epoch - misleads about scope",
            "correct": "Intent should be 'Increase Order Epoch' or 'Invalidate Old Orders'"
          },
          {
            "wrong": "Intent: 'Transfer Tokens' for a function that also stakes them",
            "why_critical": "Hides the staking action - user thinks it's just a transfer"
          },
          {
            "wrong": "Intent: 'Swap' for a generic execute/multicall function",
            "why_critical": "Function can do arbitrary operations, not just swaps"
          }
        ],
        "NOT_critical_for_generic_functions": {
          "description": "Generic execution functions (execute, call, multicall) can have generic or specific intent labels",
          "examples": [
            "execute(bytes data) with intent 'Execute' - OK (generic)",
            "execute(bytes data) with intent 'Swap' - OK if the nested calldata will be decoded on next screen",
            "permitAndCall(permit, action) with intent 'Execute with Permit' - OK"
          ],
          "reason": "For wrapper/execution functions, the label on the wrapper is less important since users will see the decoded nested call on subsequent screens"
        }
      },
      "check_label_accuracy": {
        "examples": [
          {
            "wrong": "Label: 'Amount' on a field showing the recipient address",
            "why_critical": "User thinks they're seeing an amount but it's actually showing where funds go"
          },
          {
            "wrong": "Label: 'Token In' on a field showing the output token",
            "why_critical": "User thinks they're sending this token but they're actually receiving it"
          },
          {
            "wrong": "Label: 'Recipient' on msg.sender (@.from)",
            "why_critical": "Recipient implies someone else receives funds, but @.from is the caller/sender"
          },
          {
            "wrong": "Label: 'Minimum Return' on a field showing the exact amount (not minimum)",
            "why_critical": "User expects a minimum threshold but sees the exact transfer amount"
          },
          {
            "wrong": "Label: 'Fee' on the main swap amount",
            "why_critical": "User thinks this is a small fee but it's actually the full amount being swapped"
          }
        ],
        "NOT_critical_for_generic_calldata": {
          "description": "For arbitrary execution functions, calldata labels can be generic or specific",
          "example": "execute(bytes action) with label 'Swap' on action field is acceptable if nested call is decoded",
          "reason": "Users will see the actual operation on the next screen when nested calldata is decoded"
        }
      },
      "validation": [
        "Check that intent accurately describes the function's primary operation",
        "Check that labels accurately describe what the path references",
        "For amounts: verify if it's 'Amount', 'Minimum Amount', 'Maximum Amount', 'Fee', etc.",
        "For addresses: verify if it's 'Recipient', 'Sender', 'Token', 'Contract', etc.",
        "For @.from: should be 'Sender' or 'Beneficiary' (if they receive funds), NOT 'Recipient'",
        "For recipient parameters: should be 'Recipient' or 'Destination', NOT 'Sender'"
      ],
      "action": "Flag as CRITICAL with explanation of why the label/intent is misleading and what it should be instead"
    },
    {
      "id": 11,
      "title": "Labels and intents must not be longer than 20 characters",
      "description": "Hardware wallets have strict character limits for display elements",
      "limits": {
        "intent": {
          "max_characters": 20,
          "path": "context.deployment.intents.intent",
          "examples_valid": ["Swap Tokens", "Transfer NFT", "Approve Token", "Stake ETH"],
          "examples_invalid": ["Swap tokens on Uniswap V3", "Transfer NFT to recipient", "Approve unlimited tokens"]
        },
        "field_label": {
          "max_characters": 20,
          "path": "display.formats[].fields[].label",
          "examples_valid": ["Amount", "Recipient", "Token", "Deadline"],
          "examples_invalid": ["Amount to be transferred", "Recipient wallet address", "Token contract address"]
        }
      },
      "validation_rules": {
        "counting": "Count characters, not bytes (unicode characters count as 1)",
        "truncation_behavior": "Hardware wallets will truncate or reject displays with labels exceeding limits"
      },
      "issue_format": {
        "issue_template": "Intent/Label exceeds 20 character limit",
        "include_in_message": "The specific intent or label that's too long with actual character count AND a proposed shorter alternative ≤20 characters"
      },
      "recommendation_format": {
        "must_include": "Exact descriptor JSON with the shorter intent/label (VERIFY it's ≤20 chars)",
        "character_count_validation": "Count characters in your proposed fix before including it. If your fix exceeds 20 chars, DO NOT recommend it."
      },
      "severity": "critical"
    },
    {
      "id": 12,
      "title": "msg.value representation",
      "subtitle": "WHEN to use each approach",
      "approaches": [
        {
          "approach": "Use @.value",
          "when": "When function ONLY accepts native ETH"
        },
        {
          "approach": "Use input parameter",
          "when": "When function has an amount parameter that EQUALS msg.value and can be also used for other tokens"
        }
      ],
      "critical_case": "If payable function has no parameters AND no @.value field → user can't see amount being sent",
      "severity": "critical"
    },
    {
      "id": 13,
      "title": "msg.value differs from amount parameter due to protocol fees",
      "description": "When @.value (total ETH sent) differs from the amount parameter displayed, and the difference represents protocol fees",
      "rule": "This is NOT CRITICAL if the descriptor already displays the amount parameter with nativeCurrencyAddress",
      "why_not_critical": [
        "The amount parameter shows what the user is effectively sending/swapping",
        "The difference is protocol fees (common in DEX aggregators)",
        "Displaying both @.value and amount would create duplication",
        "The descriptor already uses nativeCurrencyAddress to show it's native ETH",
        "Users understand DEX transactions involve fees"
      ],
      "correct_classification": "WARNING (not critical)",
      "recommendation_action": "Check transaction samples: if any transaction has @.value different from the displayed amount parameter, add this to recommendations section",
      "recommendation_template": "In the analyzed transactions, @.value (e.g., {example_value} ETH) differs from the displayed amount parameter (e.g., {example_amount} ETH), with the difference representing protocol fees. Consider adding documentation or UI hints to explain this fee structure to users, so they understand the total ETH sent may be slightly higher than the swap amount due to protocol fees.",
      "example": {
        "transaction_value": "1.0 ETH",
        "amount_parameter": "0.979 ETH",
        "difference": "0.021 ETH (protocol fees)",
        "descriptor_shows": "Amount parameter (0.979) with nativeCurrencyAddress",
        "classification": "WARNING - mention in recommendations, NOT critical"
      },
      "critical_if": "Only flag as CRITICAL if the descriptor does NOT show the amount parameter at all",
      "severity": "warning"
    }
  ],

  "additional_requirements": {
    "array_indexing_validation": {
      "description": "When ERC-7730 uses array indexing, verify the index points to actual data relevant to the user (not sentinel values)",
      "common_issue": "Fixed-size arrays where unused slots contain 0x0000... or other sentinels",
      "how_to_check": "Look at source code and decoded transaction parameters and verify array indices reference real data, not empty/sentinel slots",
      "critical_if": "The indexed element is a sentinel (0x00) while real data exists elsewhere in the array"
    },
    "can_it_be_fixed": {
      "description": "ONLY flag as CRITICAL if the issue EXISTS in function inputs AND can be displayed with ERC-7730 spec AND can be shown in human-readable format",
      "examples": {
        "critical": "ERC-7730 doesn't show recipient but recipient is an input parameter → CRITICAL (can be fixed)",
        "not_critical": "Showing max/min amount not actual amounts (computed on-chain, not in inputs) → NOT CRITICAL (that's how the function works)"
      },
      "rule": "If the information cannot be obtained from input parameters OR cannot be displayed with ERC-7730 spec OR cannot be shown in human-readable format, it's NOT a critical issue - it's a SPEC LIMITATION"
    },
    "human_readability": {
      "description": "Parameters that can ONLY be shown as incomprehensible raw data (packed bits, liquidity numbers, technical params) are NOT critical to hide",
      "readable_format": "Can be clear signed in READABLE format (address, token amount, date) → If missing, this IS critical",
      "incomprehensible_format": "Can only be shown as RAW/incomprehensible data (packed bits, raw bytes32, complex flags, large computed values like liquidity) → If missing, this is NOT critical",
      "key_question": "Would displaying this as 'raw' format help the user understand what they're signing?",
      "answers": {
        "yes": "Critical if missing (e.g., address as hex, token amount as number)",
        "no": "NOT critical (e.g., 0x000000000000001a4 for packed traits, 1582938471982347 for liquidity)"
      }
    }
  }
}
