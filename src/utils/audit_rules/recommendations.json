{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ERC-7730 Recommendations Format",
  "description": "Guidelines for writing recommendations in ERC-7730 clear signing audit reports",
  "version": "1.0.0",

  "always_include": "Even if no critical issues found, ALWAYS include recommendations section",

  "key_points": [
    "Always provide recommendations even if no critical issues found",
    "Include spec limitations (parameters that CANNOT be clear signed)",
    "For each fix recommendation, include a CLEAR CORRECTION showing exactly what to add or change in the descriptor",
    "Use concrete examples with actual field definitions, not generic descriptions"
  ],

  "formatting_requirements": {
    "bullet_format": "USE BULLET POINTS with dashes (-), NOT numbered lists",
    "complete_sentences": "Each recommendation must be a COMPLETE, STANDALONE sentence",
    "end_with_period": "Each bullet point must END with a period (.)",
    "no_colons": "DO NOT use colons (:) at the end of recommendations",
    "no_numbers": "DO NOT start with numbers like '1.', '2.', '3.'",
    "be_specific": "DO NOT write generic recommendations that just repeat the rules. Be SPECIFIC to this descriptor. If you say 'Ensure nested calldata descriptor(s) are available', you are being too generic. Instead, say which specific selector needs a nested descriptor or don't mention it at all.",
    "no_generic_advice": "AVOID generic phrases like 'Ensure...', 'Make sure...', 'Verify...', 'Recommend wallets...'. Only include actionable, specific recommendations for THIS descriptor.",
    "CHARACTER_LIMIT_CRITICAL": {
      "rule": "ANY proposed intent MUST be ≤20 characters. ANY proposed label MUST be ≤20 characters.",
      "when_to_check": "Check character count for EVERY intent and label you recommend, regardless of what issue you're fixing",
      "examples": {
        "WRONG": {
          "recommendation": "Change intent to 'Authorize Validator Signer'",
          "character_count": 28,
          "problem": "Exceeds 20-character hardware wallet limit"
        },
        "CORRECT": {
          "recommendation": "Change intent to 'Authorize Signer'",
          "character_count": 16,
          "reason": "Under 20 characters and still clear"
        }
      },
      "validation_process": "Before recommending any intent or label: (1) COUNT the characters, (2) If >20, shorten it, (3) Verify shortened version is ≤20 chars",
      "applies_to_all_issues": "This applies when fixing misleading labels, unclear intents, or ANY issue where you propose a new intent/label"
    }
  },

  "recommendation_types": [
    {
      "type": "Fixes for critical issues",
      "description": "For each critical issue from 'Issues Found' section, write ONE bullet point",
      "requirements": [
        "States the fix clearly in human-readable language",
        "Separates explanation (description) from code (code_snippet)",
        "Description is concise (1-2 sentences), explains WHAT and WHY",
        "Code snippet contains the actual JSON to add/modify, properly formatted",
        "DO NOT embed JSON in description text - use code_snippet field instead",
        "When recommending enum mappings: Use ACTUAL values from source code if available. If values are not visible in the provided source code, use clear placeholders like 'ROLE_VALIDATOR' or '0xROLE_VALUE_FROM_CONTRACT' and explicitly state 'populate with actual role constants from the contract source code'",
        "NEVER use made-up hex values like 0x1111...1111 or 0x2222...2222 that appear to be real constants but are actually placeholders"
      ],
      "json_structure": {
        "title": "Brief, clear title of the fix",
        "description": "Human-readable explanation (1-2 sentences) - NO JSON HERE",
        "code_snippet": "Actual descriptor JSON to add or modify"
      },
      "examples": [
        {
          "title": "Add msg.value display",
          "description": "Include a field to show the native ETH fee being sent with the transaction.",
          "code_snippet": {"path": "@.value", "label": "Fee Amount", "format": "amount"}
        },
        {
          "title": "Fix inverted token addresses",
          "description": "Swap the tokenPath references so fromAmount points to the correct input token and toAmount points to the output token.",
          "code_snippet": {"fromAmount_tokenPath": "#.tokenIn", "toAmount_tokenPath": "#.tokenOut"}
        },
        {
          "title": "Show recipient address",
          "description": "Add a field to display where the tokens are being sent.",
          "code_snippet": {"path": "#.recipient", "label": "Recipient", "format": "addressName"}
        }
      ],
      "enum_mapping_examples": {
        "good_when_values_known": {
          "description": "When role constants are visible in source code",
          "example": "Add enum mapping: {\"path\": \"role\", \"format\": \"enum\", \"params\": {\"$ref\": \"$.metadata.enums.roleNames\"}} with metadata.enums.roleNames: {\"0x8f5b8b1f9f7b6e0f3b4a0a6f7b5e8c9d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b\": \"Validator\", \"0xc2a8ba48e60e8d2bf0b0e3f1c3a4e5f6e7d8c9a0b1c2d3e4f5a6b7c8d9e0f1a2\": \"Attestation\"}"
        },
        "good_when_values_unknown": {
          "description": "When role constants are NOT visible in provided source code",
          "example": "Add enum mapping for role: {\"path\": \"role\", \"format\": \"enum\", \"params\": {\"$ref\": \"$.metadata.enums.roleNames\"}}. Populate metadata.enums.roleNames with actual role constant values from the contract source code (e.g., keccak256('VALIDATOR_SIGNER_ROLE'), keccak256('ATTESTATION_SIGNER_ROLE'), etc.).",
          "note": "Clearly state that values need to be populated from source code"
        },
        "bad_placeholder_values": {
          "description": "NEVER use fake-looking hex values that appear real",
          "bad_example": "DO NOT: {\"0x1111111111111111111111111111111111111111111111111111111111111111\": \"Execute\", \"0x2222222222222222222222222222222222222222222222222222222222222222\": \"Transfer\"}",
          "why_bad": "These look like real constants but are made up, which is misleading"
        }
      }
    },
    {
      "type": "Spec limitations",
      "description": "For parameters that CANNOT be clear signed due to ERC-7730 limitations",
      "rules": [
        "These do NOT go in 'Issues Found' section",
        "List them here in Recommendations with full explanation",
        "Follow the 'ERC-7730 SPEC LIMITATIONS' format",
        "ALWAYS include these even when no critical issues exist"
      ],
      "examples": [
        "**Output token cannot be clear signed:** The `minReturn` field displays the minimum amount to receive, but the output token is determined by the pool/DEX address and not available as a function input, so ERC-7730 cannot reliably map this to a specific ERC20 address with tokenPath."
      ]
    },
    {
      "type": "Optional improvements",
      "description": "Even when descriptor is correct, suggest UX enhancements",
      "suggestions": [
        "Adding senderAddress parameter for zero-check fallbacks",
        "Better label wording",
        "Additional helpful fields",
        "Include these even when no critical issues exist"
      ],
      "format": "Still use bullet points (-), Mark them as '(Optional)' at the start, Keep them complete sentences",
      "examples": [
        "**(Optional) Add senderAddress parameter:** Consider adding `\"senderAddress\": [\"0x0000000000000000000000000000000000000000\"]` to the recipient field to handle the zero-address fallback pattern detected in the source code where `recipient == address(0) ? msg.sender : recipient`.",
        "**(Optional) Improve label clarity:** Consider changing the label from \"To\" to \"Recipient Address\" for better user clarity."
      ]
    }
  ],

  "bad_examples": [
    "1. Add an explicit field showing msg.value:",
    "2. Example snippet to include in fields:",
    "3. (Optional) If maintainers want...",
    "4. ---"
  ],

  "spec_limitations": {
    "title": "ERC-7730 SPEC LIMITATIONS",
    "rule": "If a critical parameter CANNOT be clear signed using the current ERC-7730 specification, you MUST explicitly state this with a complete explanation",
    "common_limitations": [
      {
        "limitation": "Bitmask flags",
        "description": "Parameter used with bitwise AND operations (e.g., flags & _SHOULD_CLAIM != 0)",
        "source_code_pattern": "if (param & CONSTANT != 0) or param & MASK",
        "why_unsupported": "ERC-7730's enum format only supports simple 1:1 value→label mappings. Cannot test individual bits or display multiple flag combinations",
        "example": "flags = 0x06 = REQUIRES_EXTRA_ETH + SHOULD_CLAIM cannot be shown as 'REQUIRES_EXTRA_ETH, SHOULD_CLAIM'"
      },
      {
        "limitation": "Deeply nested arrays",
        "description": "Arrays of structs containing arrays",
        "example": "path[].orders[].amounts[]"
      },
      {
        "limitation": "Dynamic data structures",
        "description": "Data computed on-chain, not in inputs"
      },
      {
        "limitation": "Complex tuples",
        "description": "Multi-level struct nesting beyond ERC-7730 path capabilities"
      },
      {
        "limitation": "Output token from pool/DEX",
        "description": "Token determined by pool address, not explicit in inputs",
        "example": "minReturn in Uniswap where pool determines output token"
      },
      {
        "limitation": "Concatenated bytes with separate length array",
        "description": "Bytes parameter that contains concatenated calldata/data for multiple operations, sliced using a separate lengths array",
        "source_code_pattern": "data.slice(position, lengths[i]) or similar pattern where data is split dynamically",
        "why_unsupported": "ERC-7730 cannot dynamically slice a concatenated bytes blob based on another array. The calldata format expects discrete per-transaction data, not a blob that needs parsing.",
        "example": "executeHotfix(values[], destinations[], data, dataLengths[]) where data contains all calldatas concatenated and must be split using dataLengths[i]",
        "what_to_recommend": "State this as a spec limitation, NOT a critical issue. Do not propose format: calldata on the concatenated blob."
      }
    ],
    "required_format": [
      "**[Parameter name] cannot be clear signed:** This parameter cannot be displayed with current ERC-7730 spec because [explain the specific limitation].",
      "**Why this matters:** [Explain what information the user is missing and the security implications]",
      "**Detected pattern:** [If applicable, show the code pattern that proves it's a limitation]"
    ],
    "example": {
      "parameter": "flags",
      "recommendation": "**flags cannot be clear signed:** This parameter cannot be displayed with current ERC-7730 spec because it is a bitmask with bitwise operations, and ERC-7730's enum format only supports simple value→label mappings without bitwise AND support.",
      "why_matters": "**Why this matters:** Users cannot see which behavior flags are enabled (SHOULD_CLAIM, REQUIRES_EXTRA_ETH, PARTIAL_FILL), affecting token routing and ETH requirements",
      "detected_pattern": "**Detected pattern:** Source code shows: `if (flags & _SHOULD_CLAIM != 0)` and `if (flags & _REQUIRES_EXTRA_ETH != 0)`"
    }
  },

  "always_provide_recommendations": {
    "rule": "Even if there are NO critical issues, you MUST still provide recommendations",
    "include": [
      "Spec limitations: Parameters that cannot be clear signed (bitmask flags, output tokens from pools, packed data, etc.)",
      "Optional improvements: Better labels, adding senderAddress parameter, display enhancements, etc.",
      "Best practices: Suggestions that improve UX even if not critical"
    ],
    "if_truly_no_recommendations": "**No additional recommendations - descriptor is comprehensive.**",
    "avoid_generic_recommendations": [
      "DO NOT say: 'Ensure nested calldata descriptor(s) are available' - this is too generic",
      "DO NOT say: 'Recommend wallets verify...' - this is out of scope for descriptor audit",
      "DO NOT say: 'Document as a spec limitation...' - just state the limitation directly",
      "DO NOT say: 'Make sure all labels remain ≤20 characters' - only mention if there's an actual label >20 chars",
      "DO NOT say: 'Spec limitation — Bitmask/packed flags cannot be clear signed:' followed by generic explanation",
      "DO NOT say: 'Spec limitation — Output token determined by pool/DEX cannot be clear signed:' followed by generic explanation",
      "DO NOT say: 'Spec limitation — Dynamic/computed data cannot be clear signed:' followed by generic explanation",
      "DO NOT say: 'Spec limitation: There are no ERC-7730 spec limitations relevant to this function...'",
      "DO NOT list spec limitations as templates - either there IS a specific limitation to mention, or don't mention limitations at all",
      "DO NOT repeat rules from the audit guidelines - be specific to THIS descriptor"
    ],
    "when_descriptor_is_perfect": "If the descriptor has no issues, no spec limitations, and no meaningful improvements to suggest, simply write: '**No additional recommendations - descriptor is comprehensive.**'"
  }
}
