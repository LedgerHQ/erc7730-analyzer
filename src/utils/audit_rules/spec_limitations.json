{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ERC-7730 Specification Limitations",
  "description": "Common spec limitations to detect when certain parameters cannot be clear signed with current ERC-7730 spec",
  "version": "1.0.0",

  "common_spec_limitations": [
    {
      "id": 1,
      "type": "Bitmask flags / Packed data",
      "description": "Source code shows `param & CONSTANT` operations or bitwise shifts",
      "why_limitation": "ERC-7730 enum cannot display multiple flag combinations or extract packed values",
      "examples": [
        "Bitpacked parameters like `traits`, `flags`, `options` with packed nonce/epoch/flags data"
      ],
      "source_code_patterns": [
        "param & CONSTANT",
        "param & _SHOULD_CLAIM != 0",
        "param & _REQUIRES_EXTRA_ETH != 0",
        "param >> 160",
        "param << 96"
      ],
      "output_format": {
        "title": "**{parameter_name} cannot be clear signed:**",
        "explanation": "This parameter is a bitmask combining multiple boolean flags ({flag_names}). ERC-7730's enum format only supports simple 1:1 value→label mappings and cannot perform bitwise AND operations or display multiple flags simultaneously.",
        "why_matters": "**Why this matters:** Users cannot see which behavior flags are enabled, affecting {impact_description}",
        "detected_pattern": "**Detected pattern:** Source code shows: {code_patterns}"
      },
      "example_output": "**desc.flags cannot be clear signed:** This parameter is a bitmask combining multiple boolean flags (SHOULD_CLAIM=0x04, REQUIRES_EXTRA_ETH=0x02, PARTIAL_FILL=0x01). ERC-7730's enum format only supports simple 1:1 value→label mappings and cannot perform bitwise AND operations or display multiple flags simultaneously.\n\n**Why this matters:** Users cannot see which behavior flags are enabled, affecting token routing (SHOULD_CLAIM changes recipient), ETH requirements (REQUIRES_EXTRA_ETH allows extra msg.value), and partial fill logic.\n\n**Detected pattern:** Source code shows: `if (flags & _SHOULD_CLAIM != 0)`, `if (flags & _REQUIRES_EXTRA_ETH != 0)`, and `if (flags & _PARTIAL_FILL != 0)`"
    },
    {
      "id": 2,
      "type": "Output token determined by pool/DEX",
      "description": "Output token computed from pool address, not explicit in inputs",
      "why_limitation": "Cannot reliably map to specific ERC20 address",
      "examples": [
        "`minReturn` in Uniswap pool swaps where pool determines output token"
      ],
      "source_code_patterns": [
        "IPool(pool).token0()",
        "IPool(pool).token1()",
        "getPair(tokenA, tokenB)",
        "getPool(address) returns (IERC20)"
      ],
      "output_format": {
        "title": "**{parameter_name} output token cannot be clear signed:**",
        "explanation": "The output token for this amount is determined by the pool/DEX address and not available as an explicit function input, so ERC-7730 cannot reliably map this to a specific ERC20 address with tokenPath.",
        "why_matters": "**Why this matters:** Users will see the amount but not the token symbol/decimals, making it difficult to verify they're receiving the correct token type.",
        "detected_pattern": "**Detected pattern:** Output token is computed from pool address: {code_pattern}"
      },
      "example_output": "**minReturn output token cannot be clear signed:** The output token for this amount is determined by the pool/DEX address and not available as an explicit function input, so ERC-7730 cannot reliably map this to a specific ERC20 address with tokenPath.\n\n**Why this matters:** Users will see the amount but not the token symbol/decimals, making it difficult to verify they're receiving the correct token type.\n\n**Detected pattern:** Output token is computed from pool address: `IUniswapV2Pair(pools[-1]).token1()`"
    },
    {
      "id": 3,
      "type": "Deeply nested arrays",
      "description": "Arrays of structs containing arrays",
      "why_limitation": "Path like `orders[].amounts[]` beyond spec capabilities",
      "examples": [
        "orders[].fills[].tokens[]",
        "routes[].swaps[].pools[]"
      ],
      "output_format": {
        "title": "**{parameter_name} cannot be clear signed:**",
        "explanation": "This parameter has deeply nested array structure ({path_structure}) that exceeds current ERC-7730 path capabilities for array indexing.",
        "why_matters": "**Why this matters:** Users cannot see {what_user_misses}."
      }
    },
    {
      "id": 4,
      "type": "Dynamic/computed data",
      "description": "Values calculated on-chain, not in function inputs",
      "why_limitation": "Data is not available in transaction calldata",
      "examples": [
        "Actual swap amounts (only min/max in inputs)",
        "Computed fees based on on-chain state",
        "Dynamic recipients based on contract logic"
      ],
      "output_format": {
        "title": "**{data_description} cannot be clear signed:**",
        "explanation": "This value is computed on-chain during execution and is not present in the function inputs, so ERC-7730 cannot display it (only calldata parameters can be shown).",
        "why_matters": "**Why this matters:** Users will see {what_they_see_instead} rather than the actual {what_they_miss}."
      }
    },
    {
      "id": 5,
      "type": "Arbitrary low-level calls",
      "description": "Functions that execute arbitrary calldata (multicall, delegatecall to self)",
      "why_limitation": "Not necessary to decode arbitrary actions, users understand these are generic execution functions",
      "examples": [
        "multicall(bytes[] calldata data)",
        "execute(bytes calldata data)",
        "aggregate((address target, bytes calldata)[] calls)"
      ],
      "source_code_patterns": [
        ".delegatecall(data)",
        ".call(data)",
        "for (uint256 i = 0; i < data.length; i++) { address(this).delegatecall(data[i]); }"
      ],
      "output_format": {
        "title": "**Nested call data cannot be fully clear signed:**",
        "explanation": "This function executes arbitrary encoded calldata. While the high-level function can be clear signed, the nested calls within the calldata parameter {calldata_param_name} would require recursive ERC-7730 descriptors for each possible nested function.",
        "why_matters": "**Why this matters:** This is acceptable for generic execution functions where users understand they're batching multiple operations. Each nested operation should ideally have its own ERC-7730 descriptor if it's a known function."
      }
    }
  ],

  "formatting_requirements": {
    "always_include_three_parts": [
      "**{Parameter/concept} cannot be clear signed:** [Main explanation]",
      "**Why this matters:** [User impact]",
      "**Detected pattern:** [Code evidence if applicable]"
    ],
    "use_bullet_points": false,
    "note": "Spec limitations are typically written as 2-3 paragraph blocks, not bullet points"
  },

  "when_to_include": {
    "rule": "ONLY include spec limitations when they ACTUALLY APPLY to this specific descriptor",
    "location": "In the Recommendations section, NOT in Critical Issues section",
    "reasoning": "These are not bugs in the descriptor - they are inherent limitations of what ERC-7730 can express",
    "critical_rules": [
      "DO NOT write generic template-style limitations like 'Spec limitation — Bitmask/packed flags cannot be clear signed: parameters encoded as bitmasks...'",
      "DO NOT list all possible limitation types as if explaining the spec",
      "ONLY mention a limitation if you detect it applies to THIS specific function/descriptor",
      "When you mention a limitation, be SPECIFIC: which parameter, what pattern you detected, why it matters for THIS function",
      "If there are NO spec limitations for this function, do NOT mention spec limitations at all"
    ],
    "good_example": "**The makerTraits parameter cannot be clear signed:** This parameter is a bitpacked uint256 that encodes the maker's nonce (bits 0-79), deadline (bits 80-159), and useBitInvalidator flag (bit 255). ERC-7730 cannot extract or display individual flags from bitpacked data. Users will not see whether per-order cancellation or mass invalidation is being used.",
    "bad_examples": [
      "Spec limitation — Bitmask/packed flags cannot be clear signed: parameters encoded as bitmasks cannot be meaningfully expanded...",
      "Spec limitation — Output token determined by pool/DEX cannot be clear signed: when the output token is computed...",
      "Spec limitation: There are no ERC-7730 spec limitations relevant to this function..."
    ]
  }
}
