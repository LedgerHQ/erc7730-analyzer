{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ERC-7730 Validation Rules",
  "description": "Comprehensive validation rules for ERC-7730 clear signing security audits. Defines what is critical vs not critical.",
  "version": "1.0.0",

  "critical_definition": "USER LOSES MONEY OR GETS WRONG TOKENS/AMOUNTS IN FINAL OUTCOME. Only flag if a normal user would be shocked by what actually happens.",

  "key_question": "Would a regular user be shocked by the FINAL tokens/amounts sent and received, or WHO receives them? NO → DO NOT flag. YES → Flag as critical.",

  "critical_issues": [
    {
      "id": "wrong_amount_in",
      "title": "Final amount IN is WRONG",
      "description": "User sends 100 USDC but ERC-7730 shows 50 USDC",
      "severity": "critical"
    },
    {
      "id": "wrong_amount_out",
      "title": "Final amount OUT is WRONG",
      "description": "User receives 1 ETH but ERC-7730 shows 2 ETH",
      "severity": "critical"
    },
    {
      "id": "inverted_tokens",
      "title": "Token addresses INVERTED",
      "description": "ERC-7730 shows 'USDC→DAI' but logs show 'DAI→USDC'",
      "severity": "critical"
    },
    {
      "id": "wrong_token",
      "title": "Completely WRONG token",
      "description": "ERC-7730 shows user sends/receives USDC but they actually send/receive DAI",
      "exception": "If tokenPath points to user-supplied parameter (e.g., sendingAssetId) but contract mechanism differs (e.g., sends native ETH from address(this).balance), this is a DISPLAY ISSUE, NOT CRITICAL. User chose the token ID in their input. Only CRITICAL if displayed token is completely unrelated to any user input.",
      "severity": "critical"
    },
    {
      "id": "missing_recipient",
      "title": "Missing RECIPIENT parameter",
      "cases": [
        {
          "case": "A",
          "description": "If recipient IS an INPUT parameter that receives funds and is NOT shown",
          "severity": "critical"
        },
        {
          "case": "B",
          "description": "If recipient is NOT in ABI inputs (because it's always msg.sender) BUT is important to show",
          "action": "Recommend using {\"path\": \"@.from\", \"label\": \"Beneficiary\", \"format\": \"addressName\"}",
          "severity": "recommendation"
        },
        {
          "case": "C",
          "description": "If recipient IS an INPUT parameter BUT code shows conditional fallback to msg.sender (e.g., `recipient = (param == address(0)) ? msg.sender : param`)",
          "pattern": "(param == address(0)) or similar zero-check",
          "action": "Add WARNING in detailed report (not critical, but recommend adding \"senderAddress\": [\"0x0000000000000000000000000000000000000000\"])",
          "severity": "warning"
        }
      ]
    },
    {
      "id": "broken_ref",
      "title": "Broken $ref references",
      "description": "Format references non-existent definitions/constants (display will fail)",
      "severity": "critical"
    },
    {
      "id": "parameter_path_mismatch",
      "title": "Input parameter path mismatch",
      "description": "ERC-7730 references a parameter path that doesn't exist in the ABI OR uses wrong path/name",
      "examples": ["format shows '_receiver' but ABI has 'receiver'", "shows '_tokens[0]' but should be '_swapData[0].token'"],
      "severity": "critical"
    }
  ],

  "not_critical_patterns": [
    {
      "id": "amount_capped",
      "title": "Amount capped to user's available balance/debt",
      "description": "If a function takes an amount parameter from user and caps the actual transferred amount to user's balance/debt/limit (using min() or similar)",
      "patterns": [
        "amount = min(amount, userBalance)",
        "if (amount > debt) amount = debt",
        "paybackAmount = amount < debt ? amount : debt"
      ],
      "common_functions": ["repay()", "withdraw()", "redeem()"],
      "reason": "The cap is a PROTECTIVE mechanism, not a risk. User cannot be charged more than they owe or lose more than they have.",
      "action": "Mark as NOT CRITICAL but add to RECOMMENDATIONS: 'Amount may be capped to user's outstanding debt/balance. This protects user from overpaying. Consider updating label to show this.'",
      "counter_example": "If user can be charged MORE than they specify (amount multiplied/increased) → CRITICAL"
    },
    {
      "id": "funds_to_msg_sender",
      "title": "Funds always sent to msg.sender",
      "description": "If a function has no recipient parameter OR recipient parameter defaults to msg.sender, and transfers tokens/ETH exclusively to msg.sender",
      "patterns": [
        "transfer(msg.sender, amount)",
        "safeTransfer(msg.sender, ...)",
        "recipient = msg.sender",
        "to = msg.sender"
      ],
      "common_functions": ["withdraw()", "claim()", "claimRewards()", "redeem()", "unwrap()", "unstake()"],
      "reason": "There is no risk of funds going to wrong address - hardcoded to caller",
      "action": "Mark as NOT CRITICAL but add to RECOMMENDATIONS: 'Function sends funds to msg.sender (caller). Consider adding {\"path\": \"@.from\", \"label\": \"Beneficiary\", \"format\": \"addressName\"} for clarity'",
      "counter_example": "If recipient CAN be different from msg.sender (user-supplied parameter) → CRITICAL to show"
    },
    {
      "id": "cryptographically_protected",
      "title": "Cryptographically protected parameters (signed orders/meta-transactions)",
      "description": "If a parameter is part of a struct that is hashed and signature-verified (e.g., EIP-712 signed orders), it cannot be changed by an attacker without making signature validation fail",
      "patterns": [
        "orderHash = order.hash() or similar EIP-712 hashing",
        "isValidSignature(signer, hash, signature)",
        "ECDSA.recover(hash, signature) == signer"
      ],
      "common_patterns": ["Limit orders (0x, 1inch, CoW)", "Meta-transactions", "Signed permits"],
      "reason": "The parameter is tamper-proof. An attacker cannot modify it without the private key that created the signature.",
      "action": "Mark as NOT CRITICAL but add to RECOMMENDATIONS: 'Parameter is cryptographically protected by signature validation and cannot be tampered with'",
      "counter_example": "If the parameter is NOT signature-verified OR can be modified after signature check → CRITICAL"
    },
    {
      "id": "bundled_permit",
      "title": "Bundled permit/approval parameters",
      "description": "If a function has a permit or approval parameter that is excluded from display, executes permit/approval logic, performs OTHER actions beyond just approval, and the approval is consumed atomically in the SAME transaction",
      "common_patterns": ["permitAndCall()", "swapWithPermit()", "depositWithPermit()"],
      "reason": "The permit is an implementation detail for the main action. Users care about the MAIN ACTION (swap, deposit), not the approval mechanism. The approval scope is limited to this transaction and consumed immediately.",
      "action": "Mark as NOT CRITICAL",
      "counter_example": "Standalone approve() or permit() function with no other action → MUST show token/spender/amount"
    },
    {
      "id": "bitpacked_parameters",
      "title": "Bitpacked/flags parameters excluded but control behavior",
      "description": "Any parameter that uses bitpacking (bit shifts, bit masks, flags) to control multiple behaviors in a single uint256 cannot be meaningfully displayed to users",
      "patterns": [
        "flags & _SHOULD_CLAIM != 0",
        "param & MASK",
        "if (param & CONSTANT != 0)",
        "MakerTraitsLib.useBitInvalidator(traits)",
        "traits.useBitInvalidator()"
      ],
      "examples": [
        {
          "function": "cancelOrders(makerTraits[], orderHashes[])",
          "parameter": "makerTraits",
          "what_it_controls": "Whether to use per-order cancellation or mass invalidation (bit invalidator) via useBitInvalidator() flag, plus nonce/epoch value",
          "why_not_critical": "makerTraits is a bitpacked uint256 that encodes multiple flags and fields. Displaying as raw (0x00000000000000000000000000000000000000000000000000000000000001a4) is meaningless - users cannot determine if bit invalidator is used or what epoch/nonce applies. This is an ERC-7730 SPEC LIMITATION, not a critical issue."
        }
      ],
      "reason": "Displaying as raw would show '0x00000000000000000000000000000000000000000000000000000000000001a4' - users CANNOT understand what this hex means or determine operation mode from it. This is a COMPREHENSION LIMITATION.",
      "action": "Add to spec limitations section with explanation: '[Parameter name] bitpacked parameter controls [behavior description] but cannot be meaningfully displayed. Users cannot determine [specific modes/options] from raw hex.' NOT in critical issues.",
      "critical_only_if": "The parameter can be meaningfully displayed in a way users can understand AND verify. If only displayable as incomprehensible raw hex, it is NOT critical."
    },
    {
      "id": "wrapper_forwarding",
      "title": "Payable wrapper/forwarding pattern",
      "description": "Payable function that forwards execution and value entirely. Pattern detection: (1) Function body does NOT manipulate msg.value in its own logic, (2) Function forwards the ENTIRE value via delegatecall or .call{value: msg.value}, (3) Function does NOT display @.value in ERC-7730",
      "patterns": [
        "delegatecall(...) - automatically forwards msg.value",
        ".call{value: msg.value}(...) - explicitly forwards full msg.value",
        ".call{value: address(this).balance}(...) - forwards all received ETH"
      ],
      "reason": "The value is forwarded entirely to a nested call. The nested call will have its own ERC-7730 descriptor that SHOULD display @.value. Users see multiple clear signing screens: one for wrapper, one for nested call. The value is shown on the nested call's screen, not the wrapper's screen.",
      "action": "Mark as INFORMATIONAL (not CRITICAL) with note: 'This appears to be a wrapper function that forwards execution and value entirely. Verify that nested call descriptors display @.value.'",
      "counter_example": "If function validates or manipulates msg.value (e.g., require(msg.value == desc.amount)) → CRITICAL"
    },
    {
      "id": "nested_calldata",
      "title": "Nested calldata parameter excluded or shown as raw",
      "description": "MULTI-SCREEN CLEAR SIGNING: When a function contains nested calldata (e.g., action bytes passed to delegatecall/call), the nested call gets decoded on SUBSEQUENT screens using its own ERC-7730 descriptor",
      "example": "permitAndCall(permit, action) shows 'Execute with permit' on screen 1, then the decoded swap/transfer from action bytes on screens 2-3",
      "reason": "Whether the outer descriptor uses format: calldata or excludes the calldata parameter entirely is fine - users WILL see the nested call details on later screens. The outer function only needs to show what's relevant at its level.",
      "action": "DO NOT flag as critical"
    },
    {
      "id": "incomprehensible_raw_data",
      "title": "Parameters only displayable as incomprehensible raw hex/numbers",
      "description": "Even if technically possible to show as 'raw' format, if the value is meaningless to users, it's NOT critical to hide",
      "examples": [
        {
          "param": "Bitpacked parameter",
          "display": "0x00000000000000000000000000000000000000000000000000000000000001a4",
          "reason": "Users cannot understand packed bits"
        },
        {
          "param": "liquidity",
          "display": "1582938471982347",
          "reason": "Large computed value requiring mathematical context"
        },
        {
          "param": "sqrtPriceX96, tick, feeGrowthGlobal0X128",
          "display": "Various large numbers",
          "reason": "Uniswap V3 technical parameters - users cannot verify correctness without deep protocol knowledge"
        }
      ],
      "rule": "Do NOT recommend displaying parameters as 'raw' format unless the raw value is meaningful to users. If the only way to show something is incomprehensible, it's acceptable to hide it."
    },
    {
      "id": "sentinel_values",
      "title": "Sentinel values like CONTRACT_BALANCE, ADDRESS_THIS",
      "description": "Implementation details users don't see",
      "action": "NOT critical"
    },
    {
      "id": "eth_weth_wrapping",
      "title": "ETH/WETH wrapping scenarios",
      "description": "When transaction value is non-zero (user sends ETH) but tokenIn parameter is WETH, this is VALID if the function automatically wraps ETH→WETH",
      "common_functions": ["swapExactETHForTokens"],
      "reason": "The user KNOWS they're sending ETH (shown in wallet UI), and seeing WETH in the clear signing is correct because that's what the contract receives after wrapping",
      "action": "NOT critical"
    },
    {
      "id": "internal_approvals",
      "title": "Internal approvals/transfers done BY the protocol during execution",
      "description": "If not triggered by user params",
      "action": "NOT critical"
    },
    {
      "id": "recipient_sentinel",
      "title": "Recipient being a constant/sentinel value",
      "description": "As long as user receives tokens",
      "action": "NOT critical"
    },
    {
      "id": "contract_balance_logic",
      "title": "Contract balance logic",
      "description": "Implementation detail",
      "action": "NOT critical"
    },
    {
      "id": "internal_routing",
      "title": "Internal routing",
      "description": "Users don't care HOW swap happens",
      "action": "NOT critical"
    },
    {
      "id": "technical_parameters",
      "title": "ANY parameter regular users wouldn't understand without reading contract source code",
      "description": "Solidity/Vyper implementation details",
      "action": "NOT critical"
    },
    {
      "id": "unpredictable_state",
      "title": "State changes that cannot be predicted from function parameters alone",
      "action": "NOT critical"
    },
    {
      "id": "unused_metadata",
      "title": "Unused definitions/constants in metadata",
      "description": "Cleanup issue, NOT critical",
      "action": "Mention in detailed report"
    },
    {
      "id": "negative_array_indices",
      "title": "Negative array indices",
      "description": "This is part of the ERC-7730 spec to access last element and is REQUIRED to work",
      "action": "NOT critical - spec compliant"
    },
    {
      "id": "spec_features",
      "title": "ERC-7730 spec features",
      "description": "Do NOT flag spec-compliant features as 'may not be supported' - they MUST be supported",
      "action": "NOT critical"
    },
    {
      "id": "token_display_differs",
      "title": "Token type display uses user input but contract mechanism differs",
      "description": "When the display uses a user-supplied parameter for token type (e.g., sendingAssetId) but the contract's internal logic uses a different mechanism (e.g., native ETH from address(this).balance)",
      "reason": "This is a DISPLAY ISSUE for the detailed report, NOT critical. The user specified the token in their input, so the display is showing what they requested.",
      "action": "Display issue, not critical"
    },
    {
      "id": "token_fixed_address",
      "title": "tokenAmount uses 'token' parameter instead of 'tokenPath'",
      "description": "Using 'token': '0x...' is valid for hardcoded token addresses",
      "example": "Migration contracts that only operate on one specific token like CHSB",
      "action": "NOT critical - valid alternative to tokenPath"
    },
    {
      "id": "token_amount_no_tokenpath",
      "title": "tokenAmount without tokenPath when token address cannot be determined from inputs",
      "description": "NOT CRITICAL if function ONLY supports native ETH OR destination token is not in inputs (computed on-chain) OR token address cannot be determined from inputs due to 7730 limitation AND has nativeCurrencyAddress",
      "action": "Add WARNING in detailed report explaining the limitation"
    },
    {
      "id": "token_amount_raw_format",
      "title": "Token amount displayed as raw format instead of tokenAmount",
      "description": "NOT CRITICAL if the token address cannot be determined from function inputs (e.g., output token computed from pools/routes)",
      "reason": "This is an acceptable concession",
      "action": "Only mention in recommendations: 'User will see raw amount without token symbol/decimals because output token cannot be determined from inputs.'"
    },
    {
      "id": "type_casting_uint_address",
      "title": "Type mismatch: uint256 displayed as addressName",
      "description": "NOT CRITICAL - valid casting",
      "example": "pools.[-1] as uint256 can be cast to address by taking 20 bytes",
      "action": "NOT critical"
    },
    {
      "id": "type_casting_bytes_address",
      "title": "Type mismatch: bytes32 displayed as addressName",
      "description": "NOT CRITICAL - valid casting, bytes32 can be interpreted as address",
      "action": "NOT critical"
    },
    {
      "id": "bitmask_not_displayed",
      "title": "Bitmask flags parameter not displayed",
      "description": "NOT CRITICAL if source code shows bitwise AND operations (e.g., flags & _SHOULD_CLAIM) because ERC-7730 spec cannot display bitmasks",
      "action": "Add to 'Parameters that cannot be clear signed' section with explanation"
    },
    {
      "id": "output_token_from_pool",
      "title": "Output token determined by pool/DEX not shown",
      "description": "NOT CRITICAL (SPEC LIMITATION)",
      "example": "minReturn in ethUnoswap where DEX/pool determines output token. Cannot reliably map to specific ERC20 address.",
      "action": "Add to spec limitations section"
    },
    {
      "id": "arbitrary_lowlevel_calls",
      "title": "Arbitrary low-level call details not shown",
      "description": "NOT CRITICAL. Multicall/delegatecall to self with arbitrary actions - users understand these are generic execution functions",
      "reason": "No need to decode arbitrary calldata",
      "action": "NOT critical"
    },
    {
      "id": "recipient_senderaddress_missing",
      "title": "Recipient field without senderAddress param when source code has zero-check fallback",
      "description": "NOT CRITICAL but add WARNING in detailed report",
      "pattern": "recipient = (param == address(0)) ? msg.sender : param",
      "action": "Recommend adding 'senderAddress': ['0x0000000000000000000000000000000000000000'] to handle zero address fallback"
    },
    {
      "id": "nonpayable_eth_option",
      "title": "Non-payable function shows ETH as possible input (nativeCurrencyAddress present)",
      "description": "NOT CRITICAL (UX improvement only). Transaction will revert if user tries to send ETH to non-payable function - no funds lost. UI/frontend likely prevents this.",
      "action": "Add to RECOMMENDATIONS: 'Consider removing nativeCurrencyAddress for better UX' but do NOT flag as critical"
    },
    {
      "id": "enum_path_variants",
      "title": "Enum references $.metadata.enums instead of $.metadata.constants",
      "description": "NOT CRITICAL. Both $.metadata.enums.* and $.metadata.constants.* are valid paths for enum $ref",
      "example": "\"$ref\": \"$.metadata.enums.interestRateMode\" is correct",
      "action": "NOT critical"
    }
  ],

  "spec_limitations": [
    {
      "id": "bitmask_flags",
      "title": "Bitmask flags / Packed data",
      "description": "Source code shows param & CONSTANT operations or bitwise shifts",
      "reason": "ERC-7730 enum cannot display multiple flag combinations or extract packed values",
      "examples": ["Bitpacked parameters like traits, flags, options with packed nonce/epoch/flags data"]
    },
    {
      "id": "output_token_pool",
      "title": "Output token determined by pool/DEX",
      "description": "Output token computed from pool address, not explicit in inputs",
      "reason": "Cannot reliably map to specific ERC20 address",
      "examples": ["minReturn in Uniswap pool swaps where pool determines output token"]
    },
    {
      "id": "deeply_nested_arrays",
      "title": "Deeply nested arrays",
      "description": "Path like orders[].amounts[] beyond spec capabilities"
    },
    {
      "id": "dynamic_computed_data",
      "title": "Dynamic/computed data",
      "description": "Values calculated on-chain, not in function inputs"
    },
    {
      "id": "arbitrary_calls",
      "title": "Arbitrary low-level calls",
      "description": "Functions that execute arbitrary calldata (multicall, delegatecall to self)",
      "reason": "Not necessary to decode arbitrary actions, users understand these are generic execution functions"
    }
  ]
}
